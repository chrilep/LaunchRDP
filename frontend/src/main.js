// LaunchRDP Frontend - Wails Implementation
// Provides host/user management, RDP generation & launch logic.

// Import Wails Go bindings (auto-generated by Wails build)
import {
  GetUsers,
  GetHosts,
  CreateUser,
  UpdateUser,
  DeleteUser,
  CreateHost,
  UpdateHost,
  DeleteHost,
  LaunchRDP,
  LogMessage,
  CreateHostFull,
  UpdateHostFull,
  GetMousePosition,
  GenerateHostRDP,
  GetWindowBorderInfo,
} from "../wailsjs/go/main/LaunchRDPApp";

console.log("LaunchRDP Wails frontend loaded");

// Global state
let users = [];
let hosts = [];
let currentColumn = 1;
let editingHostId = null;
let editingUserId = null;
let windowBorderInfo = null;

// ========== BASIC UI FEEDBACK ==========
// Removed: showAlert function - no popups needed

// ========== API HELPER (Wrapper around Wails Bindings) ==========
// Centralizes calls for logging & error handling
async function apiCall(name, ...args) {
  try {
    switch (name) {
      case "GetUsers":
        return await GetUsers();
      case "GetHosts":
        return await GetHosts();
      case "CreateUser": {
        const [data] = args; // {username, login, domain, password}
        return await CreateUser(
          data.username,
          data.login || data.username,
          data.domain || "",
          data.password || ""
        );
      }
      case "UpdateUser": {
        const [data] = args; // {id, username, login, domain, password}
        return await UpdateUser(
          data.id,
          data.username,
          data.login || data.username,
          data.domain || "",
          data.password || ""
        );
      }
      case "DeleteUser": {
        const [data] = args; // {id}
        return await DeleteUser(data.id);
      }
      case "CreateHostFull": {
        const [d] = args; // full host creation
        return await CreateHostFull(
          d.name || d.address,
          d.address,
          d.user_id || "",
          d.port || 3389,
          d.display_mode || "window",
          d.position_x || 100,
          d.position_y || 100,
          d.window_width || 1200,
          d.window_height || 800,
          !!d.redirect_clipboard,
          !!d.redirect_drives
        );
      }
      case "UpdateHostFull": {
        const [d] = args; // full host update
        return await UpdateHostFull(
          d.id,
          d.name || d.address,
          d.address,
          d.user_id || "",
          d.port || 3389,
          d.display_mode || "window",
          d.position_x || 100,
          d.position_y || 100,
          d.window_width || 1200,
          d.window_height || 800,
          !!d.redirect_clipboard,
          !!d.redirect_drives
        );
      }
      case "DeleteHost": {
        const [data] = args; // {id}
        return await DeleteHost(data.id);
      }
      case "LaunchRDP": {
        // args: hostID, userID, posX, posY OR single object
        if (args.length === 1 && typeof args[0] === "object") {
          const d = args[0];
          return await LaunchRDP(
            d.hostID || d.hostId || d.host_id,
            d.userID || d.userId || d.user_id,
            d.positionX || d.posX || 0,
            d.positionY || d.posY || 0
          );
        }
        const [hostID, userID, posX = 0, posY = 0] = args;
        return await LaunchRDP(hostID, userID, posX, posY);
      }
      case "LogMessage": {
        const [data] = args; // {level,message}
        return await LogMessage(data.level || "info", data.message);
      }
      case "GetMousePosition": {
        return await GetMousePosition();
      }
      case "GenerateHostRDP": {
        const [data] = args; // {hostID}
        return await GenerateHostRDP(data.hostID || data.id);
      }
      case "GetWindowBorderInfo": {
        return await GetWindowBorderInfo();
      }
      default:
        throw new Error("Unknown API call: " + name);
    }
  } catch (error) {
    const detail =
      error && error.message ? error.message : JSON.stringify(error);
    console.error("API call failed:", name, detail);
    throw new Error(detail);
  }
}

// Backend logging function
function logToBackend(message, ...args) {
  let fullMessage = String(message);
  if (args.length > 0) {
    fullMessage +=
      " " +
      args
        .map((arg) =>
          typeof arg === "object" ? JSON.stringify(arg) : String(arg)
        )
        .join(" ");
  }

  console.log("[Backend]", fullMessage);
  try {
    apiCall("LogMessage", { level: "info", message: fullMessage });
  } catch (e) {
    // Ignore logging failures
  }
}

// ========== NAVIGATION ==========
function showColumn(columnNumber) {
  const container = document.querySelector(".columns-container");
  const translateX = -((columnNumber - 1) * 100);
  container.style.transform = `translateX(${translateX}vw)`;

  // Update navigation buttons
  document
    .querySelectorAll(".nav-button")
    .forEach((btn) => btn.classList.remove("active"));

  const buttons = document.querySelectorAll(".nav-button");
  if (columnNumber === 2 && buttons[0]) {
    buttons[0].classList.add("active"); // Hosts button
  } else if (columnNumber === 3 && buttons[1]) {
    buttons[1].classList.add("active"); // Users button
  }

  currentColumn = columnNumber;

  // Load data when entering list columns
  if (columnNumber === 2) loadHosts();
  if (columnNumber === 3) loadUsers();
  if (columnNumber === 1) {
    // Ensure visibility state correct when returning to edit host
    toggleWindowSettings();
  }
}

// Toggle window settings visibility
function toggleWindowSettings() {
  const displayMode = document.getElementById("host-display-mode").value;
  // Stop polling first if leaving window mode to avoid one more update causing flicker
  if (displayMode !== "window") {
    stopMousePolling();
  }
  const windowSettings = document.getElementById("window-settings");
  if (windowSettings) {
    if (displayMode === "window") {
      windowSettings.classList.remove("hidden-fullscreen");
    } else {
      windowSettings.classList.add("hidden-fullscreen");
    }
  }
  // Hide entire calculation section (header + content)
  const calcSection = document.getElementById("calculation-section");
  if (calcSection) {
    if (displayMode === "window") {
      calcSection.classList.remove("hidden-fullscreen");
    } else {
      calcSection.classList.add("hidden-fullscreen");
    }
  }
  if (displayMode === "window") {
    startMousePolling();
  }
}

// (Removed) Legacy inline handler export no longer needed; all events bound via JS now.

// Global error forwarding to backend log
window.addEventListener("error", (ev) => {
  try {
    const msg = `JS Error: ${ev.message} @ ${ev.filename}:${ev.lineno}:${ev.colno}`;
    apiCall("LogMessage", { level: "error", message: msg });
  } catch (_) {}
});
window.addEventListener("unhandledrejection", (ev) => {
  try {
    const reason = ev.reason
      ? ev.reason.message || JSON.stringify(ev.reason)
      : "unknown";
    const msg = `UnhandledPromiseRejection: ${reason}`;
    apiCall("LogMessage", { level: "error", message: msg });
  } catch (_) {}
});

// Mouse polling (desktop absolute coordinates via backend)
let mousePollHandle = null;
function startMousePolling() {
  if (mousePollHandle) return;
  mousePollHandle = setInterval(async () => {
    if (currentColumn !== 1) return;
    const mode = document.getElementById("host-display-mode")?.value;
    if (mode !== "window") return;
    try {
      const pos = await apiCall("GetMousePosition", {});
      const el = document.getElementById("mouse-position");
      if (el && pos) el.textContent = `${pos.x},${pos.y}`;
    } catch (_) {}
  }, 100);
}
function stopMousePolling() {
  if (mousePollHandle) {
    clearInterval(mousePollHandle);
    mousePollHandle = null;
  }
}

// ========== HOST MANAGEMENT ==========
function addNewHost() {
  editingHostId = null;
  clearHostForm();
  showColumn(1);
  // Start polling only if default mode is window (clearHostForm sets window)
  const mode = document.getElementById("host-display-mode")?.value;
  if (mode === "window") startMousePolling();
}

async function editHost(hostId) {
  console.log("editHost invoked", hostId);
  const host = hosts.find((h) => h.id === hostId);
  if (!host) {
    console.warn("editHost host not found", hostId);
    return;
  }
  editingHostId = host.id;
  populateHostForm(host);
  showColumn(1); // Column 1 is Edit Host
  // Only start polling if resulting mode after populate is window
  const mode = document.getElementById("host-display-mode")?.value;
  if (mode === "window") startMousePolling();
  else stopMousePolling();
}

async function saveHostAndReturn() {
  if (validateHostForm()) {
    await saveHost();
    showColumn(2); // Return to Hosts list
  }
}

function removeHost(hostId) {
  deleteHost(hostId);
}

async function saveHost() {
  const hostId = document.getElementById("host-id").value;
  const name = document.getElementById("host-name")?.value.trim() || "";
  const address = document.getElementById("host-address").value.trim();
  const port = parseInt(document.getElementById("host-port").value) || 3389;
  const userId = document.getElementById("host-user").value || "";
  const displayMode =
    document.getElementById("host-display-mode")?.value || "window";
  const posX = parseInt(document.getElementById("host-pos-x")?.value) || 100;
  const posY = parseInt(document.getElementById("host-pos-y")?.value) || 100;
  const winWidth =
    parseInt(document.getElementById("host-width")?.value) || 1200;
  const winHeight =
    parseInt(document.getElementById("host-height")?.value) || 800;
  const redirectClipboard =
    !!document.getElementById("host-clipboard")?.checked;
  const redirectDrives = !!document.getElementById("host-drives")?.checked;
  try {
    if (hostId) {
      await apiCall("UpdateHostFull", {
        id: hostId,
        address,
        name: name || address,
        user_id: userId,
        port,
        display_mode: displayMode,
        position_x: posX,
        position_y: posY,
        window_width: winWidth,
        window_height: winHeight,
        redirect_clipboard: redirectClipboard,
        redirect_drives: redirectDrives,
      });
      // Removed: showAlert("Host updated", "success");
      try {
        const rdpPath = await apiCall("GenerateHostRDP", { hostID: hostId });
        // Removed: if (rdpPath) showAlert("RDP file regenerated", "info");
      } catch (e) {
        console.error("RDP regeneration failed:", e.message);
      }
    } else {
      await apiCall("CreateHostFull", {
        address,
        name: name || address,
        user_id: userId,
        port,
        display_mode: displayMode,
        position_x: posX,
        position_y: posY,
        window_width: winWidth,
        window_height: winHeight,
        redirect_clipboard: redirectClipboard,
        redirect_drives: redirectDrives,
      });
      // Removed: showAlert("Host created", "success");
      // Need newly created host ID to generate RDP; reload hosts and find by address/name combination
      await loadHosts();
      const created = hosts.find(
        (h) => h.address === address && (h.name === name || h.name === address)
      );
      if (created) {
        try {
          const rdpPath = await apiCall("GenerateHostRDP", {
            hostID: created.id,
          });
          // Removed: if (rdpPath) showAlert("RDP file generated", "info");
        } catch (e) {
          console.error("RDP generation failed:", e.message);
        }
      }
      return; // loadHosts already called
    }
    await loadHosts();
  } catch (e) {
    console.error("Saving failed:", e.message);
  }
}
// Validation
function validateHostForm() {
  const address = document.getElementById("host-address").value.trim();
  if (!address) {
    console.warn("Host address is required");
    return false;
  }
  return true;
}

function clearHostForm() {
  const f = (id, value = "") => {
    const el = document.getElementById(id);
    if (el) el.value = value;
  };
  f("host-id", "");
  f("host-name", "");
  f("host-address", "");
  f("host-port", "3389"); // keep default port
  f("host-pos-x", "");
  f("host-pos-y", "");
  f("host-width", "");
  f("host-height", "");
  const cbClipboard = document.getElementById("host-clipboard");
  if (cbClipboard) cbClipboard.checked = true;
  const cbDrives = document.getElementById("host-drives");
  if (cbDrives) cbDrives.checked = false;
  const selMode = document.getElementById("host-display-mode");
  if (selMode) selMode.value = "window";
  
  // Update user list without pre-selecting any user
  updateHostUserSelect(null);
  
  // Apply visibility state after reset
  toggleWindowSettings();
}

// Populate host form when editing
function populateHostForm(host) {
  if (!host) return;
  const setVal = (id, val) => {
    const el = document.getElementById(id);
    if (el) el.value = val;
  };
  setVal("host-id", host.id || "");
  setVal("host-name", host.name || host.address || "");
  setVal("host-address", host.address || "");
  setVal("host-port", host.port || 3389);

  // Refresh user list & select assigned user
  updateHostUserSelect(host.user_id);

  // Position / window size values (fallbacks for legacy fields)
  setVal("host-pos-x", host.position_x || host.pos_x || "100");
  setVal("host-pos-y", host.position_y || host.pos_y || "100");
  setVal("host-width", host.width || host.window_width || "1200");
  setVal("host-height", host.height || host.window_height || "800");

  // Display mode
  const displayMode =
    host.display_mode ||
    host.DisplayMode ||
    host.displayMode ||
    host.mode ||
    "window";
  const selMode = document.getElementById("host-display-mode");
  if (selMode)
    selMode.value = ["fullscreen", "window"].includes(displayMode)
      ? displayMode
      : "window";
  toggleWindowSettings();

  // Features (Clipboard / Drives) – default values if undefined
  const cbClipboard = document.getElementById("host-clipboard");
  if (cbClipboard)
    cbClipboard.checked =
      host.redirect_clipboard !== undefined
        ? !!host.redirect_clipboard
        : host.clipboard !== false; // default true fallback
  const cbDrives = document.getElementById("host-drives");
  if (cbDrives)
    cbDrives.checked =
      host.redirect_drives !== undefined
        ? !!host.redirect_drives
        : !!host.drives; // default false fallback

  // Apply visibility after values are set
  toggleWindowSettings();
}

async function deleteHost(hostId) {
  try {
    await apiCall("DeleteHost", { id: hostId });
    // Removed: showAlert("Host deleted", "success");
    await loadHosts();
  } catch (e) {
    console.error("Delete failed:", e.message);
  }
}

async function launchConnection(hostId) {
  const host = hosts.find((h) => h.id === hostId);
  if (!host) {
    console.warn("Host not found");
    return;
  }
  const user = users.find((u) => u.id === host.user_id);
  if (!user) {
    console.warn("No user assigned");
    return;
  }
  try {
    // LaunchRDP(hostID,userID,positionX,positionY)
    const posX = host.position_x || 0;
    const posY = host.position_y || 0;
    const wasReused = await apiCall("LaunchRDP", host.id, user.id, posX, posY);
    // Removed: showAlert for RDP launched/activated
  } catch (e) {
    console.error("Launch failed:", e?.message || JSON.stringify(e));
  }
}

async function loadHosts() {
  try {
    users = await apiCall("GetUsers");
    hosts = await apiCall("GetHosts");
    renderHosts();
    updateHostUserSelect();
  } catch (e) {
    document.getElementById("hosts-list").innerHTML =
      '<div class="loading">Error loading hosts</div>';
  }
}

function renderHosts() {
  const container = document.getElementById("hosts-list");
  if (!container) {
    console.warn(
      "renderHosts: container #hosts-list nicht gefunden (DOM noch nicht bereit?)"
    );
    return;
  }

  if (hosts.length === 0) {
    container.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #666;">
        <p>No hosts configured.</p>
        <p style="font-size: 0.9em; margin-top: 10px;">Click "Add Host" to get started.</p>
      </div>`;
    return;
  }

  const userMap = {};
  users.forEach((user) => (userMap[user.id] = user));

  container.innerHTML = hosts
    .map((host) => {
      const user = userMap[host.user_id];
      const title = host.name ? host.name : host.address;
      const subtitle = `${host.address}:${host.port}`;
      return `<div class="list-item" data-host-id="${host.id}">
               <div class="list-item-info" data-action="edit" data-host-id="${
                 host.id
               }">
                 <div class="list-item-title" data-action="edit" data-host-id="${
                   host.id
                 }">${title}</div>
                 <div class="list-item-subtitle" data-action="edit" data-host-id="${
                   host.id
                 }">${subtitle} · ${user ? user.username : "No user"}</div>
               </div>
               <div class="list-item-actions">
                 <button class="btn btn-sm btn-success" data-action="launch" data-host-id="${
                   host.id
                 }" title="Launch">Launch</button>
                 <button class="btn btn-sm btn-primary" data-action="edit" data-host-id="${
                   host.id
                 }" title="Edit host">Edit</button>
                 <button class="btn btn-sm btn-danger" data-action="remove" data-host-id="${
                   host.id
                 }" title="Remove host">Remove</button>
               </div>
               </div>`;
    })
    .join("");
}

function updateHostUserSelect(selectedUserId = null) {
  const select = document.getElementById("host-user");
  select.innerHTML = users
    .map((user) => {
      const isSelected = selectedUserId && user.id === selectedUserId ? ' selected' : '';
      return `<option value="${user.id}"${isSelected}>${user.username}</option>`;
    })
    .join("");
}

// User Management Functions

function addNewUser() {
  editingUserId = null;
  clearUserForm();
  showColumn(4);
}

function editUser(userId) {
  editingUserId = userId;
  const user = users.find((u) => u.id === userId);
  if (user) {
    populateUserForm(user);
    showColumn(4);
  }
}

function saveUserAndReturn() {
  if (validateUserForm()) {
    saveUser();
    showColumn(3);
  }
}

function removeUser(userId) {
  // Direct removal without blocking confirm dialog (UI width issue)
  deleteUser(userId);
}

function clearUserForm() {
  document.getElementById("user-form").reset();
  document.getElementById("user-id").value = "";
}

function populateUserForm(user) {
  document.getElementById("user-id").value = user.id;
  document.getElementById("user-login").value = user.username || "";
  document.getElementById("user-domain").value = user.domain || "";
  document.getElementById("user-password").value = "********"; // placeholder
}

function validateUserForm() {
  const login = document.getElementById("user-login").value.trim();
  if (!login) {
    console.warn("Login is required");
    return false;
  }
  // On edit, password can be empty (will be kept unchanged)
  return true;
}
async function saveUser() {
  const userId = document.getElementById("user-id").value;
  const login = document.getElementById("user-login").value.trim();
  const domain = document.getElementById("user-domain").value.trim();
  let password = document.getElementById("user-password").value;
  const username = login;
  try {
    if (userId) {
      if (password === "********") {
        password = "__UNCHANGED__";
      }
      await apiCall("UpdateUser", {
        id: userId,
        username,
        login,
        domain,
        password,
      });
      // Removed: showAlert("User updated", "success");
    } else {
      await apiCall("CreateUser", { username, login, domain, password });
      // Removed: showAlert("User created", "success");
    }
    await loadUsers();
  } catch (e) {
    console.error("Saving failed:", e.message);
  }
}

async function deleteUser(userId) {
  try {
    await apiCall("DeleteUser", { id: userId });
    // Removed: showAlert("User deleted", "success");
    await loadUsers();
  } catch (e) {
    console.error("Delete failed:", e.message);
  }
}

async function loadUsers() {
  try {
    users = await apiCall("GetUsers");
    renderUsers();
  } catch (e) {
    document.getElementById("users-list").innerHTML =
      '<div class="loading">Error loading users</div>';
  }
}

function renderUsers() {
  const container = document.getElementById("users-list");
  if (!container) return;

  if (users.length === 0) {
    container.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #666;">
        <p>No users configured.</p>
        <p style="font-size: 0.9em; margin-top: 10px;">Click \"Add User\" to get started.</p>
      </div>`;
    return;
  }

  container.innerHTML = users
    .map((user) => {
      return `<div class="list-item" data-user-id="${user.id}">
               <div class="list-item-info" data-user-id="${
                 user.id
               }" data-action="edit-user">
                 <div class="list-item-title" data-user-id="${
                   user.id
                 }" data-action="edit-user">${user.username}</div>
                 <div class="list-item-subtitle" data-user-id="${
                   user.id
                 }" data-action="edit-user">${user.domain || "No domain"}</div>
               </div>
               <div class="list-item-actions">
                 <button class="btn btn-sm btn-primary" data-action="edit-user" data-user-id="${
                   user.id
                 }" title="Edit user">Edit</button>
                 <button class="btn btn-sm btn-danger" data-action="remove-user" data-user-id="${
                   user.id
                 }" title="Remove user">Remove</button>
               </div>
               </div>`;
    })
    .join("");
}

// Utility Functions
function calculateRdpClientSize(windowWidth, windowHeight) {
  const info = window.windowBorderInfo || null;
  // Fallbacks if metrics not yet loaded
  const left = info ? info.left : 8;
  const right = info ? info.right : 8;
  const top = info ? info.top : 39; // typical title bar + top border
  const bottom = info ? info.bottom : 8;
  const clientWidth = Math.max(0, windowWidth - left - right);
  const clientHeight = Math.max(0, windowHeight - top - bottom);
  return { clientWidth, clientHeight };
}

async function loadWindowBorderInfo() {
  try {
    const borderInfo = await apiCall("GetWindowBorderInfo", {});
    if (borderInfo) {
      window.windowBorderInfo = borderInfo;
      // Immediately reflect in UI if element present
      const el = document.getElementById("window-borders");
      if (el) {
        el.textContent = `L:${borderInfo.left} R:${borderInfo.right} T:${borderInfo.top} B:${borderInfo.bottom}`;
      }
    }
  } catch (error) {
    const el = document.getElementById("window-borders");
    if (el) el.textContent = "Not available";
  }
}

function updateCalculationInfo(
  windowWidth,
  windowHeight,
  actualWinPosStr = null
) {
  const clientSize = calculateRdpClientSize(windowWidth, windowHeight);

  const clientSizeElement = document.getElementById("client-size");
  if (clientSizeElement) {
    clientSizeElement.textContent = `${clientSize.clientWidth} x ${clientSize.clientHeight}`;
  }

  const windowBordersElement = document.getElementById("window-borders");
  if (windowBordersElement && window.windowBorderInfo) {
    const info = window.windowBorderInfo;
    windowBordersElement.textContent = `L:${info.left} R:${info.right} T:${info.top} B:${info.bottom}`;
  } else if (windowBordersElement) {
    windowBordersElement.textContent = "Not available";
  }

  const winPosStrElement = document.getElementById("winpos-str");
  if (winPosStrElement) {
    if (actualWinPosStr) {
      winPosStrElement.textContent = actualWinPosStr;
    } else {
      const x = 0;
      const y = 1;
      const left =
        x + (window.windowBorderInfo ? window.windowBorderInfo.left : 0);
      const top =
        y + (window.windowBorderInfo ? window.windowBorderInfo.top : 0);
      const right = left + clientSize.clientWidth;
      const bottom = top + clientSize.clientHeight;
      winPosStrElement.textContent = `${x},${y},${left},${top},${right},${bottom}`;
    }
  }
}

// Live Mausposition anzeigen
// Removed client-side mousemove listener to avoid conflicting mouse coordinate updates.

// Initialization
document.addEventListener("DOMContentLoaded", function () {
  loadWindowBorderInfo();
  showColumn(2); // initial view
  toggleWindowSettings(); // sync visibility

  // Navigation buttons (data-column)
  document.querySelectorAll(".nav-button[data-column]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const col = parseInt(btn.getAttribute("data-column"), 10);
      if (!isNaN(col)) showColumn(col);
    });
  });

  // Host list delegation
  const hostList = document.getElementById("hosts-list");
  if (hostList) {
    hostList.addEventListener("click", (ev) => {
      const btn = ev.target.closest("[data-action]");
      if (!btn) return;
      const action = btn.getAttribute("data-action");
      const hostId = btn.getAttribute("data-host-id");
      if (!hostId) return;
      switch (action) {
        case "launch":
          launchConnection(hostId);
          break;
        case "edit":
          editHost(hostId);
          break;
        case "remove":
          removeHost(hostId);
          break;
      }
    });
  }

  // Users list delegation
  const usersList = document.getElementById("users-list");
  if (usersList) {
    usersList.addEventListener("click", (ev) => {
      const el = ev.target.closest("[data-action]");
      if (!el) return;
      const action = el.getAttribute("data-action");
      const userId = el.getAttribute("data-user-id");
      if (!userId) return;
      switch (action) {
        case "edit-user":
          editUser(userId);
          break;
        case "remove-user":
          removeUser(userId);
          break;
      }
    });
  }

  // Add Host button
  const addHostBtn = document.getElementById("btn-add-host");
  if (addHostBtn) addHostBtn.addEventListener("click", addNewHost);

  // Add User button
  const addUserBtn = document.getElementById("btn-add-user");
  if (addUserBtn) addUserBtn.addEventListener("click", addNewUser);

  // Save Host and return
  const saveHostBtn = document.getElementById("btn-save-host-return");
  if (saveHostBtn)
    saveHostBtn.addEventListener("click", (e) => {
      e.preventDefault();
      saveHostAndReturn();
    });

  // Save User and return
  const saveUserBtn = document.getElementById("btn-save-user-return");
  if (saveUserBtn)
    saveUserBtn.addEventListener("click", (e) => {
      e.preventDefault();
      saveUserAndReturn();
    });

  // Display mode select change
  const displayModeSelect = document.getElementById("host-display-mode");
  if (displayModeSelect)
    displayModeSelect.addEventListener("change", () => {
      toggleWindowSettings();
    });

  // Width/Height live calculation
  const widthInput = document.getElementById("host-width");
  const heightInput = document.getElementById("host-height");
  if (widthInput && heightInput) {
    const updateCalc = () => {
      const width = parseInt(widthInput.value) || 1200;
      const height = parseInt(heightInput.value) || 800;
      updateCalculationInfo(width, height);
    };
    widthInput.addEventListener("input", updateCalc);
    heightInput.addEventListener("input", updateCalc);
    updateCalc();
  }
});

// Removed: loadHosts() directly on load; executed via showColumn(2) after DOMContentLoaded

// (Removed) Global exports for onclick inline handlers; now using modular event listeners.

// Override console to redirect logs to backend only
(() => {
  const original = {
    log: console.log.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    info: console.info.bind(console),
    debug: console.debug
      ? console.debug.bind(console)
      : console.log.bind(console),
  };
  async function backendLog(level, args) {
    const msg = args
      .map((a) => (typeof a === "object" ? JSON.stringify(a) : String(a)))
      .join(" ");
    try {
      await apiCall("LogMessage", { level, message: msg });
    } catch (_) {
      /* swallow */
    }
  }
  [
    ["log", "info"],
    ["info", "info"],
    ["warn", "warn"],
    ["error", "error"],
    ["debug", "debug"],
  ].forEach(([fn, lvl]) => {
    console[fn] = (...args) => {
      backendLog(lvl, args);
    };
  });
})();
